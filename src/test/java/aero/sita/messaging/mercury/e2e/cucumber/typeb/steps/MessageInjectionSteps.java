/*
 * This code contains copyright information which is the proprietary property
 * of SITA Information Network Computing Limited (SITA). No part of this
 * code may be reproduced, stored or transmitted in any form without the prior
 * written permission of SITA.
 * Copyright Â© SITA Information Networking Computing Ireland Limited 2020-2025.
 * Confidential. All rights reserved.
 */

package aero.sita.messaging.mercury.e2e.cucumber.typeb.steps;

import aero.sita.messaging.mercury.e2e.utilities.format.typeb.TypeBMessage;
import aero.sita.messaging.mercury.e2e.utilities.format.typeb.TypeBMessageFactory;
import aero.sita.messaging.mercury.e2e.utilities.generator.MessageIdentityGenerator;
import aero.sita.messaging.mercury.e2e.utilities.helper.MessageInjectionHelper;
import aero.sita.messaging.mercury.e2e.utilities.helper.PollingHelper;
import io.cucumber.java.en.When;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;

/**
 * Step definitions for message injection scenarios.
 * This class contains step definitions related to injecting messages
 * into the Mercury system via the test-harness.
 * <p>
 * Each injected message receives a unique message identity generated by
 * MessageIdentityGenerator for proper test isolation and traceability.
 */
@Slf4j
public class MessageInjectionSteps {

  @Autowired
  private MessageInjectionHelper messageInjectionHelper;

  @Autowired
  private MessageBuildSteps messageBuildSteps;

  @Autowired
  private CommonSteps commonSteps;

  @Autowired
  private PollingHelper pollingHelper;

  /**
   * Gets the last injected message content.
   */
  @Getter
  private String lastInjectedMessage;

  /**
   * Gets the last generated message identity.
   */
  @Getter
  private String lastMessageIdentity;

  /**
   * Gets the last exception that occurred during injection.
   */
  @Getter
  private Exception lastException;

  @When("this type-b message is sent through mercury")
  public void thisTypeBMessageIsSentThroughMercury() {
    log.info("Injecting a valid Type B message with unique messageIdentity");

    try {
      TypeBMessage message = messageBuildSteps.getMessage();
      // Inject the message
      messageInjectionHelper.injectTypeB(message);
      log.info("Successfully injected Type B message with messageIdentity: {}", lastMessageIdentity);
    } catch (Exception e) {
      log.error("Failed to inject message: {}", e.getMessage(), e);
      lastException = e;
    }
  }

  /**
   * Injects a valid Type B message using default settings with a unique message identity.
   * The message identity is automatically generated using MessageIdentityGenerator.
   * <p>
   * Example Gherkin:
   * When I inject a valid Type B message
   */
  @When("I inject a valid Type B message")
  public void injectAValidTypeBMessage() {
    log.info("Injecting a valid Type B message with unique messageIdentity");

    try {
      // Generate unique message identity using utility class
      String messageIdentity = MessageIdentityGenerator.generate();
      lastMessageIdentity = messageIdentity;

      log.info("Generated unique messageIdentity: {}", messageIdentity);

      // Create Type B message with the unique message identity
      TypeBMessage message = TypeBMessageFactory.validMessageWithIdentity(messageIdentity);
      lastInjectedMessage = message.toMessageString();

      // Store the message identity for MongoDB queries
      commonSteps.setMessageIdentity(messageIdentity);

      // Inject the message
      messageInjectionHelper.injectTypeB(message);
      lastException = null;

      log.info("Successfully injected Type B message with messageIdentity: {}", messageIdentity);
    } catch (Exception e) {
      log.error("Failed to inject message: {}", e.getMessage(), e);
      lastException = e;
    }
  }

  /**
   * Injects a message to a specific destination with a unique message identity.
   * <p>
   * Example Gherkin:
   * When I inject a message to server "localhost" port 2017 queue "TEST.QUEUE"
   *
   * @param server    the target server address
   * @param port      the target server port
   * @param queueName the target queue name
   */
  @When("I inject a message to server {string} port {int} queue {string}")
  public void injectAMessageToServerPortQueue(String server, Integer port, String queueName) {
    log.info("Injecting message to {}:{} queue: {}", server, port, queueName);

    try {
      // Generate unique message identity using utility class
      String messageIdentity = MessageIdentityGenerator.generate();
      lastMessageIdentity = messageIdentity;

      log.info("Generated unique messageIdentity: {}", messageIdentity);

      // Create Type B message with the unique message identity
      TypeBMessage message = TypeBMessageFactory.validMessageWithIdentity(messageIdentity);
      lastInjectedMessage = message.toMessageString();

      // Store the message identity for MongoDB queries
      commonSteps.setMessageIdentity(messageIdentity);

      // Inject the message to specific destination
      messageInjectionHelper.injectTypeB(message, server, port, queueName);
      lastException = null;

      log.info("Successfully injected Type B message to {}:{} queue: {} with messageIdentity: {}",
          server, port, queueName, messageIdentity);
    } catch (Exception e) {
      log.error("Failed to inject message to specific destination: {}", e.getMessage(), e);
      lastException = e;
    }
  }

  /**
   * Injects a custom Type B message with specified fields and a unique message identity.
   * <p>
   * Example Gherkin:
   * When I inject a Type B message with heading "FF" address "LHRBA7X" origin "JFKAA7X" and text "MVT"
   *
   * @param heading the heading line (priority indicator)
   * @param address the address line (destination)
   * @param origin  the origin line (source)
   * @param text    the message text
   */
  @When("I inject a Type B message with heading {string} address {string} origin {string} and text {string}")
  public void injectATypeBMessageWithFields(String heading, String address, String origin, String text) {
    log.info("Injecting custom Type B message");

    try {
      // Generate unique message identity using utility class
      String messageIdentity = MessageIdentityGenerator.generate();
      lastMessageIdentity = messageIdentity;

      log.info("Generated unique messageIdentity: {}", messageIdentity);

      // Create custom Type B message with the unique message identity
      TypeBMessage message = TypeBMessageFactory.customMessageWithIdentity(
          heading, address, origin, text, messageIdentity);
      lastInjectedMessage = message.toMessageString();

      // Store the message identity for MongoDB queries
      commonSteps.setMessageIdentity(messageIdentity);

      // Inject the message
      messageInjectionHelper.injectTypeB(message);
      lastException = null;

      log.info("Successfully injected custom Type B message with messageIdentity: {}", messageIdentity);
    } catch (Exception e) {
      log.error("Failed to inject custom Type B message: {}", e.getMessage(), e);
      lastException = e;
    }
  }

  /**
   * Injects multiple messages, each with a unique message identity.
   * Includes a small delay between messages to ensure timestamp uniqueness.
   * <p>
   * Example Gherkin:
   * When I inject 5 messages
   *
   * @param count number of messages to inject
   */
  @When("I inject {int} messages")
  public void injectMultipleMessages(int count) {
    log.info("Injecting {} messages with unique messageIdentities", count);

    try {
      for (int i = 0; i < count; i++) {
        // Generate unique message identity for each message using utility class
        String messageIdentity = MessageIdentityGenerator.generate();

        // Create Type B message with the unique message identity
        TypeBMessage message = TypeBMessageFactory.validMessageWithIdentity(messageIdentity);

        // Inject the message
        messageInjectionHelper.injectTypeB(message);

        log.debug("Injected message {}/{} with messageIdentity: {}", i + 1, count, messageIdentity);

        // Small delay to ensure unique timestamps if generating many messages quickly
        if (i < count - 1) {
          pollingHelper.waitForMillis(10);
        }
      }

      lastException = null;
      log.info("Successfully injected {} messages", count);
    } catch (Exception e) {
      log.error("Failed to inject multiple messages: {}", e.getMessage(), e);
      lastException = e;
    }
  }

  /**
   * Injects a Type B message with a UUID-based message identity.
   * Useful for scenarios requiring globally unique identifiers.
   * <p>
   * Example Gherkin:
   * When I inject a Type B message with UUID-based identity
   */
  @When("I inject a Type B message with UUID-based identity")
  public void injectATypeBMessageWithUuidBasedIdentity() {
    log.info("Injecting a Type B message with UUID-based messageIdentity");

    try {
      // Generate UUID-based message identity using utility class
      String messageIdentity = MessageIdentityGenerator.generateUuidBased();
      lastMessageIdentity = messageIdentity;

      log.info("Generated UUID-based messageIdentity: {}", messageIdentity);

      // Create Type B message with the UUID-based message identity
      TypeBMessage message = TypeBMessageFactory.validMessageWithIdentity(messageIdentity);
      lastInjectedMessage = message.toMessageString();

      // Store the message identity for MongoDB queries
      commonSteps.setMessageIdentity(messageIdentity);

      // Inject the message
      messageInjectionHelper.injectTypeB(message);
      lastException = null;

      log.info("Successfully injected Type B message with UUID-based messageIdentity: {}", messageIdentity);
    } catch (Exception e) {
      log.error("Failed to inject message with UUID-based identity: {}", e.getMessage(), e);
      lastException = e;
    }
  }
}